<?php
/**
 * Capitularia Meta Search
 *
 * @package Capitularia_Meta_Search
 */

namespace cceh\capitularia\meta_search;

use \cceh\capitularia\lib;

/**
 * A query manipulation class.
 */

class MetaSearch
{
    /** The result returned by the App server */
    private $json;

    /**
     * Runs the meta query on the Capitularia VM server.
     *
     * Runs the meta query on the server, which returns the ids of the
     * manuscripts that contain the search terms.  Then builds a Wordpress query
     * that searches for the pages that contain those manuscripts.
     *
     * Then the program flow goes back to the normal Wordpress search page,
     * except that we also provide the snippets to display and the chapter
     * information.
     *
     * @param \WP_Query $query The Wordpress query object
     *
     * @return void
     *
     * @see https://codex.wordpress.org/Class_Reference/WP_Query Class Reference
     *      for \WP_Query
     */

    public function on_pre_get_posts ($query)
    {
        // don't interfere with standard Wordpress query
        if (is_meta_search () && $query->is_main_query ()) {
            // The metadata is kept on the API server, so reflect the query there. This
            // is the same query as in the browser location bar, plus the 'status'
            // parameter.
            $this->json = lib\api_json_request (
                '/data/query_manuscripts.json/',
                $query->query,
                true
            );
            $xml_ids = array_map (
                function ($item) {
                    return $item['ms_id'];
                },
                $this->json
            );
            if (!$xml_ids) {
                // Wordpress doesn't understand the empty array case.  It
                // returns everything instead of returning nothing.
                $xml_ids = array ('none-such-id');
            }

            // The data server already did all the heavy lifting for us.
            // The Wordpress query only has to filter the manuscripts by
            // tei-xml-id.
            $meta_query_args = array (array (
                'key' => 'tei-xml-id',
                'value' => $xml_ids,
                'compare' => 'IN',
                'type' => 'CHAR'
            ));

            $query->set ('meta_query', $meta_query_args);
            $query->query_vars['search_terms'] = array ();

            /* Output titles in alphabetical order. */
            $query->set ('orderby', 'title');
            $query->set ('order', 'ASC');

            /* If you want results paged. */
            $paged = max (1, intval (get_query_var ('paged')));
            $query->set ('paged', $paged);
            $query->set ('posts_per_page', 10);

            /* If you don't want results paged. */
            // $query->set ('nopaging', true);
        }
    }

    /**
     * Get the excerpt for the search result
     *
     * Return the excerpt generated by the VM Server.
     *
     * @return string The excerpt (with HTML)
     */

    public function on_get_the_excerpt ()
    {
        $id     = get_the_ID ();
        $href   = apply_filters ('cap_meta_search_the_permalink', get_the_permalink ());
        $xml_id = get_post_meta ($id, 'tei-xml-id', true);

        $excerpts = [];
        foreach ($this->json as $s) {
            if ($s['ms_id'] === $xml_id && $s['snippet']) {
                $hr    = $s['cap_id'] . ($s['chapter'] ? "&#x2009;c.&#x2009;{$s['chapter']}" : '');
                $locus = $s['locus'];
                $excerpts[] = "<li class='snippet'><a href='$href#$locus' class='excerpt-corresp'>{$hr}:</a> {$s['snippet']}</li>";
            }
        }
        return '<ul class="snippet-list">' .  join ('', $excerpts) . '</ul>';
    }

    /**
     * Format the contents of the search query variables.
     *
     * Generate a string like "BK.123 not before 950 and 'Karl'".  This hook is
     * called from the search.php page, and serves to insert the text outside
     * our widget.
     *
     * @param string $dummy_message The old message
     *
     * @return string The message
     */

    public function on_get_search_query ($dummy_message) // phpcs:ignore
    {
        $your_search = [];

        foreach ($_GET as $key => $val) {
            // error_log ("key = $key, value = $val");
            if (empty ($val)) {
                continue;
            }
            if ($key == 'capit') {
                $your_search[] = sprintf (__ ('contains %s', DOMAIN), $val);
            }
            if ($key == 'notbefore') {
                $your_search[] = sprintf (__ ('after %d', DOMAIN), absint ($val));
            }
            if ($key == 'notafter') {
                $your_search[] = sprintf (__ ('before %d', DOMAIN), absint ($val));
            }
            if ($key == 'placenames') {
                if (is_array ($val)) {
                    $your_search[] = sprintf (
                        __ ('origin in %s', DOMAIN),
                        implode (', ', $val)
                    );
                }
            }
            if ($key == 'fulltext') {
                $your_search[] = stripslashes ($val);
            }
        }
        return htmlspecialchars (implode (' Â· ', $your_search));
    }
}
